
Ejercicios 1 y 2:
Tenemos que crear los contenedores sin red, es decir, con la opción --network none.
Esto quiere decir que el contenedor no estará asociado a ningún namespace de red, por 
tanto, tenemos que meterlo nosotros en uno de los que podemos crear con iproute2.

Un contenedor de docker es un grupo de procesos aislados del resto del sistema a través 
de cgroups. Cada proceso está en una serie de namespaces (de usuario, de pid, de red...) 
el objetivo es meter estos contenedores en el namespace de red que queramos.

Cada proceso tiene en /proc/[pid]/ns una serie de links simbólicos que indican los namespaces 
en los que está el proceso (Si haces ls -l te indica los descriptores de fichero de los 
ficheros a los que apuntan esos enlaces, parece que lo que importa es ese File descriptor, y 
no lo que haya en el fichero al que estás apuntando). Por defecto, cualquier proceso que se 
crea estará en los namespaces por defecto.

Referencia:
https://man7.org/linux/man-pages/man7/namespaces.7.html

https://man7.org/linux/man-pages/man7/network_namespaces.7.html

En concreto, nos interesa /proc/[pid]/ns/net

Podemos ver en https://man7.org/linux/man-pages/man8/ip-netns.8.html, que los namespaces creados 
con ip netns add NAME se crean en /var/run/netns

Según https://www.boynux.com/advanced-docker-networking/ para meter un contenedor en un namespace 
de red bastará con asignarle ese namespace al main process del contenedor, cuyo PID podemos obtener 
con docker inspect (y filtrando el resultado con -f '{{.State.Pid}}'). Esto tiene sentido ya que 
en principio el namespace de los hijos de este proceso será el mismo, pero no tengo claro lo que 
significa para procesos ya en ejecución.

La idea no es crear un namespace con netns, sino coger el namespace que se crea para el contenedor 
y poner un enlace a ese namespace en /var/run/netns, de esa forma, por un lado sabemos que todos los 
procesos del contenedor están en el namespace, y podemos modificar el namespace con iproute2.

Por tanto, para solucionar los apartados 1 y 2, creo dos contenedores y creo enlaces en /var/run/netns 
a los namespaces de red de esos contenedores. Después, creo un enlace VETH entre los contenedores y un 
enlace desde el host a cada contenedor. Asigno direcciones IP y activo las interfaces. Por último, 
ejecuto una serie de pings desde cada extremo de cada una de las tres conexiones.

NOTA:
Al parecer, el file exists lo da si intentamos crear en un namespace una interfaz que exista en el namespace 
del host.

CAMBIO:
Hay que utilizar un bridge en vez de conexiones directas:

Creo el bridge en un namespace aparte. Creo tres conexiones veth, entre los containers y el bridge, y entre 
el host y el bridge. Les asigno IP a las interfaces en los containers y el host, a las del bridge no (es un 
switch), añado en los containers que el gateway para cualquier dirección sea su interfaz, añado en el host las 
reglas de rutado para los mensajes que vayan a los containers.


Ejercicio 3:
Para este ejercicio, mi objetivo será que los containers lleguen a hacer ping primero a una raspberry pi en 
192.168.1.254/24, y a google.com. También, que desde la raspberry se pueda hacer ping a los contenedores.

IPTABLES:

El código de filtrado de paquetes es parte del kernel de linux. Este código se organiza en una serie de tablas
predefinidas, cada una con un propósito específico, y cada tabla está compuesta de un conjunto de cadenas 
predefinidas. Cada cadena es un conjunto de reglas que se recorren en orden. Cada regla consiste en una serie 
de matches y una acción a realizar si se cumplen. A continuación, un flowchart simplificado del flujo de paquetes 
cuando usamos IPTABLES para NATing o un filtrado básico de paquetes.

En IPTABLES hay 5 tablas predefinidas:
-raw is used only for configuring packets so that they are exempt from connection tracking.
-filter is the default table, and is where all the actions typically associated with a firewall take place.
-nat is used for network address translation (e.g. port forwarding).
-mangle is used for specialized packet alterations.
-security is used for Mandatory Access Control networking rules.

Normalmente, para casos de uso sencillos sólo se usan filter y nat

Cada una de estas tablas contiene una serie de cadenas:
-raw:
--PREROUTING
--OUTPUT
-filter:
--INPUT
--FORWARD
--OUTPUT
-nat:
--PREROUTING
--INPUT
--OUTPUT
--POSTROUTING
-mangle:
--PREROUTING
--OUTPUT
--INPUT
--FORWARD
--POSTROUTING
-security:
--INPUT
--OUTPUT
--FORWARD

Cada cadena tiene una política, (por ejemplo, ACCEPT, DROP), que se aplica a los paquetes que lleguen al final de 
la cadena (esto no lo acabo de entender)

Por defecto, todas las cadenas están vacías inicialmente.

Las reglas se componen de un conjunto de condiciones y de una acción a ejecutar cuando se cumplen esas condiciones.
Las acciones por defecto son: ACCEPT, DROP, QUEUE, RETURN, también existen extensiones a estas acciones, y por último, 
las acciones pueden ser otras cadenas definidas por el usuario.

DOCKER AÑADE UNA SERIE DE CADENAS POR DEFECTO (tablas filter y nat):
https://docs.docker.com/network/iptables/

En principio no es necesario tocar nada en la tabla DOCKER. Sin embargo, todos los paquetes se evaluan antes por estas 
dos cadenas DOCKER y DOCKER-USER que por las por defecto. Esto significa que, de acuerdo con el comportamiento de 
iptables, si un paquete es aceptado por una regla ya no se recorren las demás cadenas de esa tabla (aunque sí otras 
tablas). Por tanto se proporciona la cadena DOCKER-USER para que el usuario pueda introducir reglas que se apliquen 
antes que las de DOCKER.

Docker modifica la cadena FORWARD y pone el default en DROP. Esto impide que el host funcione como un router haciendo 
forwarding de paquetes. Para evitarlo es necesario añadir reglas en docker user que acepten los paquetes con origen en 
las IPs que queramos y con destino las IPS que queramos.

Sintaxis de un comando de iptables:
iptables [-t table] command [match] [target/jump]

El comando más típico sería -A (Add)


TUTORIALES IMPORTANTES DE IPTABLES:
https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html
https://wiki.archlinux.org/index.php/iptables

/////////////////////
Uso:
sudo tcpdump -i wlan0 port not 22 and host 192.168.1.63
O bien
sudo tcpdump -i wlan0 icmp

En la raspberry para determinar si los mensajes están llegando correctamente.

Usando este tutorial:
https://wiki.archlinux.org/index.php/Router

Veo que es necesario crear una regla en la tabla de NAT para hacer MASQUERADE a los paquetes que salgan por la interfaz 
externa. (MASQUERADE es como SNAT pero para DHCP, SNAT funciona con IPs estáticas (Y es más rápido))
iptables -t nat -A POSTROUTING -o extern0 -j MASQUERADE

Imagino que, estando activado el forwarding de paquetes en el kernel, cuando llega un paquete que no es para el host se pone 
su interfaz de salida a la que toque en función de su IP de destino, así:

Regla en filter-FORWARD, cargando el módulo conntrack que nos proporciona más información sobre el estado de la conexión, usando 
conntrack usamos --ctstate, y hacemos match a los estados RELATED (paquetes que están estableciendo una conexión) y 
ESTABLISHED, el target es ACCEPT
iptables -t filter -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

Regla que acepta los paquetes que entren en una interfaz y salgan por otra
iptables -t filter -A FORWARD -i intern0 -o extern0 -j ACCEPT

El siguiente problema es hacer que se pueda establecer una conexión desde fuera con los contenedores. Para servicios concretos 
esto es tan sencillo como hacer port forwarding. Si quiero hacer ping desde fuera, no va a ser tan sencillo. Los paquetes 
ICMP están por debajo de la capa de transporte, por lo que no usan puertos, esto hace que aunque haga port forwarding, no se 
pueda saber a qué máquina enviar los mensajes, ya que no estarán dirigidos a un puerto en concreto.

Para solucionar este problema, instalo un servidor web nginx en la imágen, y abro el puerto 80 de ambos containers. Para hacer 
port forwarding hago:
iptables -A PREROUTING -t nat -i wlp0s20u1 -p tcp --dport 8000 -j DNAT --to 192.168.2.1:80

Que en este caso redirige el puerto 8000 del host al 80 del container 1. Si la política de la tabla FORWARD, que se evalúa después 
de esto no fuera ACCEPT, habría que aceptar los paquetes a esa IP y puerto manualmente:
iptables -A FORWARD -p tcp -d 192.168.2.1 --dport 80 -j ACCEPT


Ejercicio 4:

Para que los contenedores en nodos diferentes puedan comunicarse entre sí, tenemos que poner en cada nodo que la ruta 
hacia un contenedor en otro de los nodos pasa por ese nodo donde están desplegados. Por tanto, una forma no genérica de 
hacerlo es símplemente poner esa regla de rutado en cada nodo, apuntando al resto de nodos con contenedores.










